import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart';

import 'package:olm/src/ffi_base.dart';

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint

/// Bindings to LibOLM
class LibOLM {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibOLM(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibOLM.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// get the size of an inbound group session, in bytes.
  int olm_inbound_group_session_size() {
    return _olm_inbound_group_session_size();
  }

  late final _olm_inbound_group_session_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'olm_inbound_group_session_size');
  late final _olm_inbound_group_session_size =
      _olm_inbound_group_session_sizePtr.asFunction<int Function()>();

  /// Initialise an inbound group session object using the supplied memory
  /// The supplied memory should be at least olm_inbound_group_session_size()
  /// bytes.
  ffi.Pointer<ffi.NativeType> olm_inbound_group_session(
    ffi.Pointer<ffi.Uint8> memory,
  ) {
    return _olm_inbound_group_session(
      memory,
    );
  }

  late final _olm_inbound_group_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeType> Function(
              ffi.Pointer<ffi.Uint8>)>>('olm_inbound_group_session');
  late final _olm_inbound_group_session =
      _olm_inbound_group_sessionPtr.asFunction<
          ffi.Pointer<ffi.NativeType> Function(ffi.Pointer<ffi.Uint8>)>();

  /// A null terminated string describing the most recent error to happen to a
  /// group session
  ffi.Pointer<Utf8> olm_inbound_group_session_last_error(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    return _olm_inbound_group_session_last_error(
      session,
    );
  }

  late final _olm_inbound_group_session_last_errorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_inbound_group_session_last_error');
  late final _olm_inbound_group_session_last_error =
      _olm_inbound_group_session_last_errorPtr.asFunction<
          ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>();

  /// An error code describing the most recent error to happen to a group
  /// session
  OlmErrorCode olm_inbound_group_session_last_error_code(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    return OlmErrorCode.fromValue(_olm_inbound_group_session_last_error_code(
      session,
    ));
  }

  late final _olm_inbound_group_session_last_error_codePtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_inbound_group_session_last_error_code');
  late final _olm_inbound_group_session_last_error_code =
      _olm_inbound_group_session_last_error_codePtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Clears the memory used to back this group session
  int olm_clear_inbound_group_session(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_clear_inbound_group_session(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_clear_inbound_group_sessionPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_clear_inbound_group_session');
  late final _olm_clear_inbound_group_session =
      _olm_clear_inbound_group_sessionPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Returns the number of bytes needed to store an inbound group session
  int olm_pickle_inbound_group_session_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_pickle_inbound_group_session_length(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_pickle_inbound_group_session_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_pickle_inbound_group_session_length');
  late final _olm_pickle_inbound_group_session_length =
      _olm_pickle_inbound_group_session_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Stores a group session as a base64 string. Encrypts the session using the
  /// supplied key. Returns the length of the session on success.
  ///
  /// Returns olm_error() on failure. If the pickle output buffer
  /// is smaller than olm_pickle_inbound_group_session_length() then
  /// olm_inbound_group_session_last_error() will be "OUTPUT_BUFFER_TOO_SMALL"
  int olm_pickle_inbound_group_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> pickled,
    int pickled_length,
  ) {
    int result = _olm_pickle_inbound_group_session(
      session,
      key,
      key_length,
      pickled,
      pickled_length,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_pickle_inbound_group_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pickle_inbound_group_session');
  late final _olm_pickle_inbound_group_session =
      _olm_pickle_inbound_group_sessionPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>, int)>();

  /// Loads a group session from a pickled base64 string. Decrypts the session
  /// using the supplied key.
  ///
  /// Returns olm_error() on failure. If the key doesn't match the one used to
  /// encrypt the account then olm_inbound_group_session_last_error() will be
  /// "BAD_ACCOUNT_KEY". If the base64 couldn't be decoded then
  /// olm_inbound_group_session_last_error() will be "INVALID_BASE64". The input
  /// pickled buffer is destroyed
  int olm_unpickle_inbound_group_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> pickled,
    int pickled_length,
  ) {
    int result = _olm_unpickle_inbound_group_session(
      session,
      key,
      key_length,
      pickled,
      pickled_length,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_unpickle_inbound_group_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_unpickle_inbound_group_session');
  late final _olm_unpickle_inbound_group_session =
      _olm_unpickle_inbound_group_sessionPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>, int)>();

  /// Start a new inbound group session, from a key exported from
  /// olm_outbound_group_session_key
  ///
  /// Returns olm_error() on failure. On failure last_error will be set with an
  /// error code. The last_error will be:
  ///
  /// * OLM_INVALID_BASE64  if the session_key is not valid base64
  /// * OLM_BAD_SESSION_KEY if the session_key is invalid
  int olm_init_inbound_group_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> session_key,
    int session_key_length,
  ) {
    int result = _olm_init_inbound_group_session(
      session,
      session_key,
      session_key_length,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_init_inbound_group_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_init_inbound_group_session');
  late final _olm_init_inbound_group_session =
      _olm_init_inbound_group_sessionPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Import an inbound group session, from a previous export.
  ///
  /// Returns olm_error() on failure. On failure last_error will be set with an
  /// error code. The last_error will be:
  ///
  /// * OLM_INVALID_BASE64  if the session_key is not valid base64
  /// * OLM_BAD_SESSION_KEY if the session_key is invalid
  int olm_import_inbound_group_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> session_key,
    int session_key_length,
  ) {
    int result = _olm_import_inbound_group_session(
      session,
      session_key,
      session_key_length,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_import_inbound_group_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_import_inbound_group_session');
  late final _olm_import_inbound_group_session =
      _olm_import_inbound_group_sessionPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Get an upper bound on the number of bytes of plain-text the decrypt method
  /// will write for a given input message length. The actual size could be
  /// different due to padding.
  ///
  /// The input message buffer is destroyed.
  ///
  /// Returns olm_error() on failure.
  int olm_group_decrypt_max_plaintext_length(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> message,
    int message_length,
  ) {
    int result = _olm_group_decrypt_max_plaintext_length(
      session,
      message,
      message_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_group_decrypt_max_plaintext_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_group_decrypt_max_plaintext_length');
  late final _olm_group_decrypt_max_plaintext_length =
      _olm_group_decrypt_max_plaintext_lengthPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Decrypt a message.
  ///
  /// The input message buffer is destroyed.
  ///
  /// Returns the length of the decrypted plain-text, or olm_error() on failure.
  ///
  /// On failure last_error will be set with an error code. The last_error will
  /// be:
  /// * OLM_OUTPUT_BUFFER_TOO_SMALL if the plain-text buffer is too small
  /// * OLM_INVALID_BASE64 if the message is not valid base-64
  /// * OLM_BAD_MESSAGE_VERSION if the message was encrypted with an unsupported
  /// version of the protocol
  /// * OLM_BAD_MESSAGE_FORMAT if the message headers could not be decoded
  /// * OLM_BAD_MESSAGE_MAC    if the message could not be verified
  /// * OLM_UNKNOWN_MESSAGE_INDEX  if we do not have a session key corresponding to the
  /// message's index (ie, it was sent before the session key was shared with
  /// us)
  int olm_group_decrypt(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> message,
    int message_length,
    ffi.Pointer<ffi.Uint8> plaintext,
    int max_plaintext_length,
    ffi.Pointer<ffi.Uint32> message_index,
  ) {
    int result = _olm_group_decrypt(
      session,
      message,
      message_length,
      plaintext,
      max_plaintext_length,
      message_index,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_group_decryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint32>)>>('olm_group_decrypt');
  late final _olm_group_decrypt = _olm_group_decryptPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint32>)>();

  /// Get the number of bytes returned by olm_inbound_group_session_id()
  int olm_inbound_group_session_id_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_inbound_group_session_id_length(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_inbound_group_session_id_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_inbound_group_session_id_length');
  late final _olm_inbound_group_session_id_length =
      _olm_inbound_group_session_id_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Get a base64-encoded identifier for this session.
  ///
  /// Returns the length of the session id on success or olm_error() on
  /// failure. On failure last_error will be set with an error code. The
  /// last_error will be OUTPUT_BUFFER_TOO_SMALL if the id buffer was too
  /// small.
  int olm_inbound_group_session_id(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> id,
    int id_length,
  ) {
    int result = _olm_inbound_group_session_id(
      session,
      id,
      id_length,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_inbound_group_session_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_inbound_group_session_id');
  late final _olm_inbound_group_session_id =
      _olm_inbound_group_session_idPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Get the first message index we know how to decrypt.
  int olm_inbound_group_session_first_known_index(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_inbound_group_session_first_known_index(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_inbound_group_session_first_known_indexPtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_inbound_group_session_first_known_index');
  late final _olm_inbound_group_session_first_known_index =
      _olm_inbound_group_session_first_known_indexPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Check if the session has been verified as a valid session.
  ///
  /// (A session is verified either because the original session share was signed,
  /// or because we have subsequently successfully decrypted a message.)
  ///
  /// This is mainly intended for the unit tests, currently.
  int olm_inbound_group_session_is_verified(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_inbound_group_session_is_verified(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_inbound_group_session_is_verifiedPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_inbound_group_session_is_verified');
  late final _olm_inbound_group_session_is_verified =
      _olm_inbound_group_session_is_verifiedPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Get the number of bytes returned by olm_export_inbound_group_session()
  int olm_export_inbound_group_session_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_export_inbound_group_session_length(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_export_inbound_group_session_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_export_inbound_group_session_length');
  late final _olm_export_inbound_group_session_length =
      _olm_export_inbound_group_session_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Export the base64-encoded ratchet key for this session, at the given index,
  /// in a format which can be used by olm_import_inbound_group_session
  ///
  /// Returns the length of the ratchet key on success or olm_error() on
  /// failure. On failure last_error will be set with an error code. The
  /// last_error will be:
  /// * OUTPUT_BUFFER_TOO_SMALL if the buffer was too small
  /// * OLM_UNKNOWN_MESSAGE_INDEX  if we do not have a session key corresponding to the
  /// given index (ie, it was sent before the session key was shared with
  /// us)
  int olm_export_inbound_group_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    int message_index,
  ) {
    int result = _olm_export_inbound_group_session(
      session,
      key,
      key_length,
      message_index,
    );
    if (result == olm_error())
      throw_olm(olm_inbound_group_session_last_error(session));
    return result;
  }

  late final _olm_export_inbound_group_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size, ffi.Uint32)>>('olm_export_inbound_group_session');
  late final _olm_export_inbound_group_session =
      _olm_export_inbound_group_sessionPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// get the size of an outbound group session, in bytes.
  int olm_outbound_group_session_size() {
    return _olm_outbound_group_session_size();
  }

  late final _olm_outbound_group_session_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'olm_outbound_group_session_size');
  late final _olm_outbound_group_session_size =
      _olm_outbound_group_session_sizePtr.asFunction<int Function()>();

  /// Initialise an outbound group session object using the supplied memory
  /// The supplied memory should be at least olm_outbound_group_session_size()
  /// bytes.
  ffi.Pointer<ffi.NativeType> olm_outbound_group_session(
    ffi.Pointer<ffi.Uint8> memory,
  ) {
    return _olm_outbound_group_session(
      memory,
    );
  }

  late final _olm_outbound_group_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeType> Function(
              ffi.Pointer<ffi.Uint8>)>>('olm_outbound_group_session');
  late final _olm_outbound_group_session =
      _olm_outbound_group_sessionPtr.asFunction<
          ffi.Pointer<ffi.NativeType> Function(ffi.Pointer<ffi.Uint8>)>();

  /// A null terminated string describing the most recent error to happen to a
  /// group session
  ffi.Pointer<Utf8> olm_outbound_group_session_last_error(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    return _olm_outbound_group_session_last_error(
      session,
    );
  }

  late final _olm_outbound_group_session_last_errorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_outbound_group_session_last_error');
  late final _olm_outbound_group_session_last_error =
      _olm_outbound_group_session_last_errorPtr.asFunction<
          ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>();

  /// An error code describing the most recent error to happen to a group
  /// session
  OlmErrorCode olm_outbound_group_session_last_error_code(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    return OlmErrorCode.fromValue(_olm_outbound_group_session_last_error_code(
      session,
    ));
  }

  late final _olm_outbound_group_session_last_error_codePtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_outbound_group_session_last_error_code');
  late final _olm_outbound_group_session_last_error_code =
      _olm_outbound_group_session_last_error_codePtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Clears the memory used to back this group session
  int olm_clear_outbound_group_session(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_clear_outbound_group_session(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_clear_outbound_group_sessionPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_clear_outbound_group_session');
  late final _olm_clear_outbound_group_session =
      _olm_clear_outbound_group_sessionPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Returns the number of bytes needed to store an outbound group session
  int olm_pickle_outbound_group_session_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_pickle_outbound_group_session_length(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_pickle_outbound_group_session_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_pickle_outbound_group_session_length');
  late final _olm_pickle_outbound_group_session_length =
      _olm_pickle_outbound_group_session_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Stores a group session as a base64 string. Encrypts the session using the
  /// supplied key. Returns the length of the session on success.
  ///
  /// Returns olm_error() on failure. If the pickle output buffer
  /// is smaller than olm_pickle_outbound_group_session_length() then
  /// olm_outbound_group_session_last_error() will be "OUTPUT_BUFFER_TOO_SMALL"
  int olm_pickle_outbound_group_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> pickled,
    int pickled_length,
  ) {
    int result = _olm_pickle_outbound_group_session(
      session,
      key,
      key_length,
      pickled,
      pickled_length,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_pickle_outbound_group_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pickle_outbound_group_session');
  late final _olm_pickle_outbound_group_session =
      _olm_pickle_outbound_group_sessionPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>, int)>();

  /// Loads a group session from a pickled base64 string. Decrypts the session
  /// using the supplied key.
  ///
  /// Returns olm_error() on failure. If the key doesn't match the one used to
  /// encrypt the account then olm_outbound_group_session_last_error() will be
  /// "BAD_ACCOUNT_KEY". If the base64 couldn't be decoded then
  /// olm_outbound_group_session_last_error() will be "INVALID_BASE64". The input
  /// pickled buffer is destroyed
  int olm_unpickle_outbound_group_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> pickled,
    int pickled_length,
  ) {
    int result = _olm_unpickle_outbound_group_session(
      session,
      key,
      key_length,
      pickled,
      pickled_length,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_unpickle_outbound_group_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_unpickle_outbound_group_session');
  late final _olm_unpickle_outbound_group_session =
      _olm_unpickle_outbound_group_sessionPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>, int)>();

  /// The number of random bytes needed to create an outbound group session
  int olm_init_outbound_group_session_random_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_init_outbound_group_session_random_length(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_init_outbound_group_session_random_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_init_outbound_group_session_random_length');
  late final _olm_init_outbound_group_session_random_length =
      _olm_init_outbound_group_session_random_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Start a new outbound group session. Returns olm_error() on failure. On
  /// failure last_error will be set with an error code. The last_error will be
  /// NOT_ENOUGH_RANDOM if the number of random bytes was too small.
  int olm_init_outbound_group_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> random,
    int random_length,
  ) {
    int result = _olm_init_outbound_group_session(
      session,
      random,
      random_length,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_init_outbound_group_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_init_outbound_group_session');
  late final _olm_init_outbound_group_session =
      _olm_init_outbound_group_sessionPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// The number of bytes that will be created by encrypting a message
  int olm_group_encrypt_message_length(
    ffi.Pointer<ffi.NativeType> session,
    int plaintext_length,
  ) {
    int result = _olm_group_encrypt_message_length(
      session,
      plaintext_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_group_encrypt_message_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>,
              ffi.Size)>>('olm_group_encrypt_message_length');
  late final _olm_group_encrypt_message_length =
      _olm_group_encrypt_message_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>, int)>();

  /// Encrypt some plain-text. Returns the length of the encrypted message or
  /// olm_error() on failure. On failure last_error will be set with an
  /// error code. The last_error will be OUTPUT_BUFFER_TOO_SMALL if the output
  /// buffer is too small.
  int olm_group_encrypt(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> plaintext,
    int plaintext_length,
    ffi.Pointer<ffi.Uint8> message,
    int message_length,
  ) {
    int result = _olm_group_encrypt(
      session,
      plaintext,
      plaintext_length,
      message,
      message_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_group_encryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_group_encrypt');
  late final _olm_group_encrypt = _olm_group_encryptPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// Get the number of bytes returned by olm_outbound_group_session_id()
  int olm_outbound_group_session_id_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_outbound_group_session_id_length(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_outbound_group_session_id_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_outbound_group_session_id_length');
  late final _olm_outbound_group_session_id_length =
      _olm_outbound_group_session_id_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Get a base64-encoded identifier for this session.
  ///
  /// Returns the length of the session id on success or olm_error() on
  /// failure. On failure last_error will be set with an error code. The
  /// last_error will be OUTPUT_BUFFER_TOO_SMALL if the id buffer was too
  /// small.
  int olm_outbound_group_session_id(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> id,
    int id_length,
  ) {
    int result = _olm_outbound_group_session_id(
      session,
      id,
      id_length,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_outbound_group_session_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_outbound_group_session_id');
  late final _olm_outbound_group_session_id =
      _olm_outbound_group_session_idPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Get the current message index for this session.
  ///
  /// Each message is sent with an increasing index; this returns the index for
  /// the next message.
  int olm_outbound_group_session_message_index(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_outbound_group_session_message_index(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_outbound_group_session_message_indexPtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_outbound_group_session_message_index');
  late final _olm_outbound_group_session_message_index =
      _olm_outbound_group_session_message_indexPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Get the number of bytes returned by olm_outbound_group_session_key()
  int olm_outbound_group_session_key_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_outbound_group_session_key_length(
      session,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_outbound_group_session_key_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_outbound_group_session_key_length');
  late final _olm_outbound_group_session_key_length =
      _olm_outbound_group_session_key_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Get the base64-encoded current ratchet key for this session.
  ///
  /// Each message is sent with a different ratchet key. This function returns the
  /// ratchet key that will be used for the next message.
  ///
  /// Returns the length of the ratchet key on success or olm_error() on
  /// failure. On failure last_error will be set with an error code. The
  /// last_error will be OUTPUT_BUFFER_TOO_SMALL if the buffer was too small.
  int olm_outbound_group_session_key(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
  ) {
    int result = _olm_outbound_group_session_key(
      session,
      key,
      key_length,
    );
    if (result == olm_error())
      throw_olm(olm_outbound_group_session_last_error(session));
    return result;
  }

  late final _olm_outbound_group_session_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_outbound_group_session_key');
  late final _olm_outbound_group_session_key =
      _olm_outbound_group_session_keyPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  late final ffi.Pointer<ffi.Size> _OLM_MESSAGE_TYPE_PRE_KEY =
      _lookup<ffi.Size>('OLM_MESSAGE_TYPE_PRE_KEY');

  int get OLM_MESSAGE_TYPE_PRE_KEY => _OLM_MESSAGE_TYPE_PRE_KEY.value;

  late final ffi.Pointer<ffi.Size> _OLM_MESSAGE_TYPE_MESSAGE =
      _lookup<ffi.Size>('OLM_MESSAGE_TYPE_MESSAGE');

  int get OLM_MESSAGE_TYPE_MESSAGE => _OLM_MESSAGE_TYPE_MESSAGE.value;

  /// Get the version number of the library.
  /// Arguments will be updated if non-null.
  void olm_get_library_version(
    ffi.Pointer<ffi.Uint8> major,
    ffi.Pointer<ffi.Uint8> minor,
    ffi.Pointer<ffi.Uint8> patch,
  ) {
    return _olm_get_library_version(
      major,
      minor,
      patch,
    );
  }

  late final _olm_get_library_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>)>>('olm_get_library_version');
  late final _olm_get_library_version = _olm_get_library_versionPtr.asFunction<
      void Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>)>();

  /// The size of an account object in bytes
  int olm_account_size() {
    return _olm_account_size();
  }

  late final _olm_account_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('olm_account_size');
  late final _olm_account_size =
      _olm_account_sizePtr.asFunction<int Function()>();

  /// The size of a session object in bytes
  int olm_session_size() {
    return _olm_session_size();
  }

  late final _olm_session_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('olm_session_size');
  late final _olm_session_size =
      _olm_session_sizePtr.asFunction<int Function()>();

  /// The size of a utility object in bytes
  int olm_utility_size() {
    return _olm_utility_size();
  }

  late final _olm_utility_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('olm_utility_size');
  late final _olm_utility_size =
      _olm_utility_sizePtr.asFunction<int Function()>();

  /// Initialise an account object using the supplied memory
  /// The supplied memory must be at least olm_account_size() bytes
  ffi.Pointer<ffi.NativeType> olm_account(
    ffi.Pointer<ffi.Uint8> memory,
  ) {
    return _olm_account(
      memory,
    );
  }

  late final _olm_accountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeType> Function(
              ffi.Pointer<ffi.Uint8>)>>('olm_account');
  late final _olm_account = _olm_accountPtr.asFunction<
      ffi.Pointer<ffi.NativeType> Function(ffi.Pointer<ffi.Uint8>)>();

  /// Initialise a session object using the supplied memory
  /// The supplied memory must be at least olm_session_size() bytes
  ffi.Pointer<ffi.NativeType> olm_session(
    ffi.Pointer<ffi.Uint8> memory,
  ) {
    return _olm_session(
      memory,
    );
  }

  late final _olm_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeType> Function(
              ffi.Pointer<ffi.Uint8>)>>('olm_session');
  late final _olm_session = _olm_sessionPtr.asFunction<
      ffi.Pointer<ffi.NativeType> Function(ffi.Pointer<ffi.Uint8>)>();

  /// Initialise a utility object using the supplied memory
  /// The supplied memory must be at least olm_utility_size() bytes
  ffi.Pointer<ffi.NativeType> olm_utility(
    ffi.Pointer<ffi.Uint8> memory,
  ) {
    return _olm_utility(
      memory,
    );
  }

  late final _olm_utilityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeType> Function(
              ffi.Pointer<ffi.Uint8>)>>('olm_utility');
  late final _olm_utility = _olm_utilityPtr.asFunction<
      ffi.Pointer<ffi.NativeType> Function(ffi.Pointer<ffi.Uint8>)>();

  /// The value that olm will return from a function if there was an error
  int olm_error() {
    return _olm_error();
  }

  late final _olm_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('olm_error');
  late final _olm_error = _olm_errorPtr.asFunction<int Function()>();

  /// A null terminated string describing the most recent error to happen to an
  /// account
  ffi.Pointer<Utf8> olm_account_last_error(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    return _olm_account_last_error(
      account,
    );
  }

  late final _olm_account_last_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Utf8> Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_account_last_error');
  late final _olm_account_last_error = _olm_account_last_errorPtr
      .asFunction<ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>();

  /// An error code describing the most recent error to happen to an account
  OlmErrorCode olm_account_last_error_code(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    return OlmErrorCode.fromValue(_olm_account_last_error_code(
      account,
    ));
  }

  late final _olm_account_last_error_codePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_account_last_error_code');
  late final _olm_account_last_error_code = _olm_account_last_error_codePtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// A null terminated string describing the most recent error to happen to a
  /// session
  ffi.Pointer<Utf8> olm_session_last_error(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    return _olm_session_last_error(
      session,
    );
  }

  late final _olm_session_last_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Utf8> Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_session_last_error');
  late final _olm_session_last_error = _olm_session_last_errorPtr
      .asFunction<ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>();

  /// An error code describing the most recent error to happen to a session
  OlmErrorCode olm_session_last_error_code(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    return OlmErrorCode.fromValue(_olm_session_last_error_code(
      session,
    ));
  }

  late final _olm_session_last_error_codePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_session_last_error_code');
  late final _olm_session_last_error_code = _olm_session_last_error_codePtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// A null terminated string describing the most recent error to happen to a
  /// utility
  ffi.Pointer<Utf8> olm_utility_last_error(
    ffi.Pointer<ffi.NativeType> utility,
  ) {
    return _olm_utility_last_error(
      utility,
    );
  }

  late final _olm_utility_last_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Utf8> Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_utility_last_error');
  late final _olm_utility_last_error = _olm_utility_last_errorPtr
      .asFunction<ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>();

  /// An error code describing the most recent error to happen to a utility
  OlmErrorCode olm_utility_last_error_code(
    ffi.Pointer<ffi.NativeType> utility,
  ) {
    return OlmErrorCode.fromValue(_olm_utility_last_error_code(
      utility,
    ));
  }

  late final _olm_utility_last_error_codePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_utility_last_error_code');
  late final _olm_utility_last_error_code = _olm_utility_last_error_codePtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Clears the memory used to back this account
  int olm_clear_account(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_clear_account(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_clear_accountPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_clear_account');
  late final _olm_clear_account = _olm_clear_accountPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Clears the memory used to back this session
  int olm_clear_session(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_clear_session(
      session,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_clear_sessionPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_clear_session');
  late final _olm_clear_session = _olm_clear_sessionPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Clears the memory used to back this utility
  int olm_clear_utility(
    ffi.Pointer<ffi.NativeType> utility,
  ) {
    int result = _olm_clear_utility(
      utility,
    );
    if (result == olm_error()) throw_olm(olm_utility_last_error(utility));
    return result;
  }

  late final _olm_clear_utilityPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_clear_utility');
  late final _olm_clear_utility = _olm_clear_utilityPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Returns the number of bytes needed to store an account
  int olm_pickle_account_length(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_pickle_account_length(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_pickle_account_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_pickle_account_length');
  late final _olm_pickle_account_length = _olm_pickle_account_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Returns the number of bytes needed to store a session
  int olm_pickle_session_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_pickle_session_length(
      session,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_pickle_session_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_pickle_session_length');
  late final _olm_pickle_session_length = _olm_pickle_session_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Stores an account as a base64 string. Encrypts the account using the
  /// supplied key. Returns the length of the pickled account on success.
  /// Returns olm_error() on failure. If the pickle output buffer
  /// is smaller than olm_pickle_account_length() then
  /// olm_account_last_error() will be "OUTPUT_BUFFER_TOO_SMALL"
  int olm_pickle_account(
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> pickled,
    int pickled_length,
  ) {
    int result = _olm_pickle_account(
      account,
      key,
      key_length,
      pickled,
      pickled_length,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_pickle_accountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pickle_account');
  late final _olm_pickle_account = _olm_pickle_accountPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// Stores a session as a base64 string. Encrypts the session using the
  /// supplied key. Returns the length of the pickled session on success.
  /// Returns olm_error() on failure. If the pickle output buffer
  /// is smaller than olm_pickle_session_length() then
  /// olm_session_last_error() will be "OUTPUT_BUFFER_TOO_SMALL"
  int olm_pickle_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> pickled,
    int pickled_length,
  ) {
    int result = _olm_pickle_session(
      session,
      key,
      key_length,
      pickled,
      pickled_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_pickle_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pickle_session');
  late final _olm_pickle_session = _olm_pickle_sessionPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// Loads an account from a pickled base64 string. Decrypts the account using
  /// the supplied key. Returns olm_error() on failure. If the key doesn't
  /// match the one used to encrypt the account then olm_account_last_error()
  /// will be "BAD_ACCOUNT_KEY". If the base64 couldn't be decoded then
  /// olm_account_last_error() will be "INVALID_BASE64". The input pickled
  /// buffer is destroyed
  int olm_unpickle_account(
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> pickled,
    int pickled_length,
  ) {
    int result = _olm_unpickle_account(
      account,
      key,
      key_length,
      pickled,
      pickled_length,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_unpickle_accountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_unpickle_account');
  late final _olm_unpickle_account = _olm_unpickle_accountPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// Loads a session from a pickled base64 string. Decrypts the session using
  /// the supplied key. Returns olm_error() on failure. If the key doesn't
  /// match the one used to encrypt the account then olm_session_last_error()
  /// will be "BAD_ACCOUNT_KEY". If the base64 couldn't be decoded then
  /// olm_session_last_error() will be "INVALID_BASE64". The input pickled
  /// buffer is destroyed
  int olm_unpickle_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> pickled,
    int pickled_length,
  ) {
    int result = _olm_unpickle_session(
      session,
      key,
      key_length,
      pickled,
      pickled_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_unpickle_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_unpickle_session');
  late final _olm_unpickle_session = _olm_unpickle_sessionPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// The number of random bytes needed to create an account.
  int olm_create_account_random_length(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_create_account_random_length(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_create_account_random_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_create_account_random_length');
  late final _olm_create_account_random_length =
      _olm_create_account_random_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Creates a new account. Returns olm_error() on failure. If there weren't
  /// enough random bytes then olm_account_last_error() will be
  /// "NOT_ENOUGH_RANDOM"
  int olm_create_account(
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> random,
    int random_length,
  ) {
    int result = _olm_create_account(
      account,
      random,
      random_length,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_create_accountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_create_account');
  late final _olm_create_account = _olm_create_accountPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// The size of the output buffer needed to hold the identity keys
  int olm_account_identity_keys_length(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_account_identity_keys_length(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_identity_keys_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_account_identity_keys_length');
  late final _olm_account_identity_keys_length =
      _olm_account_identity_keys_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Writes the public parts of the identity keys for the account into the
  /// identity_keys output buffer. Returns olm_error() on failure. If the
  /// identity_keys buffer was too small then olm_account_last_error() will be
  /// "OUTPUT_BUFFER_TOO_SMALL".
  int olm_account_identity_keys(
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> identity_keys,
    int identity_key_length,
  ) {
    int result = _olm_account_identity_keys(
      account,
      identity_keys,
      identity_key_length,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_identity_keysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_account_identity_keys');
  late final _olm_account_identity_keys =
      _olm_account_identity_keysPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// The length of an ed25519 signature encoded as base64.
  int olm_account_signature_length(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_account_signature_length(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_signature_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_account_signature_length');
  late final _olm_account_signature_length = _olm_account_signature_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Signs a message with the ed25519 key for this account. Returns olm_error()
  /// on failure. If the signature buffer was too small then
  /// olm_account_last_error() will be "OUTPUT_BUFFER_TOO_SMALL"
  int olm_account_sign(
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> message,
    int message_length,
    ffi.Pointer<ffi.Uint8> signature,
    int signature_length,
  ) {
    int result = _olm_account_sign(
      account,
      message,
      message_length,
      signature,
      signature_length,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size, ffi.Pointer<ffi.Uint8>, ffi.Size)>>('olm_account_sign');
  late final _olm_account_sign = _olm_account_signPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// The size of the output buffer needed to hold the one time keys
  int olm_account_one_time_keys_length(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_account_one_time_keys_length(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_one_time_keys_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_account_one_time_keys_length');
  late final _olm_account_one_time_keys_length =
      _olm_account_one_time_keys_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Writes the public parts of the unpublished one time keys for the account
  /// into the one_time_keys output buffer.
  /// <p>
  /// The returned data is a JSON-formatted object with the single property
  /// <tt>curve25519</tt>, which is itself an object mapping key id to
  /// base64-encoded Curve25519 key. For example:
  /// <pre>
  /// {
  /// curve25519: {
  /// "AAAAAA": "wo76WcYtb0Vk/pBOdmduiGJ0wIEjW4IBMbbQn7aSnTo",
  /// "AAAAAB": "LRvjo46L1X2vx69sS9QNFD29HWulxrmW11Up5AfAjgU"
  /// }
  /// }
  /// </pre>
  /// Returns olm_error() on failure.
  /// <p>
  /// If the one_time_keys buffer was too small then olm_account_last_error()
  /// will be "OUTPUT_BUFFER_TOO_SMALL".
  int olm_account_one_time_keys(
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> one_time_keys,
    int one_time_keys_length,
  ) {
    int result = _olm_account_one_time_keys(
      account,
      one_time_keys,
      one_time_keys_length,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_one_time_keysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_account_one_time_keys');
  late final _olm_account_one_time_keys =
      _olm_account_one_time_keysPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Marks the current set of one time keys and fallback key as being published
  /// Once marked as published, the one time keys will no longer be returned by
  /// olm_account_one_time_keys(), and the fallback key will no longer be returned
  /// by olm_account_unpublished_fallback_key().
  ///
  /// Returns the number of one-time keys that were marked as published.  Note that
  /// this count does not include the fallback key.
  int olm_account_mark_keys_as_published(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_account_mark_keys_as_published(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_mark_keys_as_publishedPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_account_mark_keys_as_published');
  late final _olm_account_mark_keys_as_published =
      _olm_account_mark_keys_as_publishedPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// The largest number of one time keys this account can store.
  int olm_account_max_number_of_one_time_keys(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_account_max_number_of_one_time_keys(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_max_number_of_one_time_keysPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_account_max_number_of_one_time_keys');
  late final _olm_account_max_number_of_one_time_keys =
      _olm_account_max_number_of_one_time_keysPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// The number of random bytes needed to generate a given number of new one
  /// time keys.
  int olm_account_generate_one_time_keys_random_length(
    ffi.Pointer<ffi.NativeType> account,
    int number_of_keys,
  ) {
    int result = _olm_account_generate_one_time_keys_random_length(
      account,
      number_of_keys,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_generate_one_time_keys_random_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>,
              ffi.Size)>>('olm_account_generate_one_time_keys_random_length');
  late final _olm_account_generate_one_time_keys_random_length =
      _olm_account_generate_one_time_keys_random_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>, int)>();

  /// Generates a number of new one time keys. If the total number of keys stored
  /// by this account exceeds max_number_of_one_time_keys() then the old keys are
  /// discarded. Returns olm_error() on error. If the number of random bytes is
  /// too small then olm_account_last_error() will be "NOT_ENOUGH_RANDOM".
  int olm_account_generate_one_time_keys(
    ffi.Pointer<ffi.NativeType> account,
    int number_of_keys,
    ffi.Pointer<ffi.Uint8> random,
    int random_length,
  ) {
    int result = _olm_account_generate_one_time_keys(
      account,
      number_of_keys,
      random,
      random_length,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_generate_one_time_keysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_account_generate_one_time_keys');
  late final _olm_account_generate_one_time_keys =
      _olm_account_generate_one_time_keysPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// The number of random bytes needed to generate a fallback key.
  int olm_account_generate_fallback_key_random_length(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_account_generate_fallback_key_random_length(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_generate_fallback_key_random_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_account_generate_fallback_key_random_length');
  late final _olm_account_generate_fallback_key_random_length =
      _olm_account_generate_fallback_key_random_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Generates a new fallback key. Only one previous fallback key is
  /// stored. Returns olm_error() on error. If the number of random bytes is too
  /// small then olm_account_last_error() will be "NOT_ENOUGH_RANDOM".
  int olm_account_generate_fallback_key(
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> random,
    int random_length,
  ) {
    int result = _olm_account_generate_fallback_key(
      account,
      random,
      random_length,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_generate_fallback_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_account_generate_fallback_key');
  late final _olm_account_generate_fallback_key =
      _olm_account_generate_fallback_keyPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// The number of bytes needed to hold the fallback key as returned by
  /// olm_account_fallback_key.
  int olm_account_fallback_key_length(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_account_fallback_key_length(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_fallback_key_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_account_fallback_key_length');
  late final _olm_account_fallback_key_length =
      _olm_account_fallback_key_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Deprecated: use olm_account_unpublished_fallback_key instead
  int olm_account_fallback_key(
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> fallback_key,
    int fallback_key_size,
  ) {
    int result = _olm_account_fallback_key(
      account,
      fallback_key,
      fallback_key_size,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_fallback_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_account_fallback_key');
  late final _olm_account_fallback_key =
      _olm_account_fallback_keyPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// The number of bytes needed to hold the unpublished fallback key as returned
  /// by olm_account_unpublished fallback_key.
  int olm_account_unpublished_fallback_key_length(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    int result = _olm_account_unpublished_fallback_key_length(
      account,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_unpublished_fallback_key_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_account_unpublished_fallback_key_length');
  late final _olm_account_unpublished_fallback_key_length =
      _olm_account_unpublished_fallback_key_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Returns the fallback key (if present, and if unpublished) into the
  /// fallback_key buffer
  int olm_account_unpublished_fallback_key(
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> fallback_key,
    int fallback_key_size,
  ) {
    int result = _olm_account_unpublished_fallback_key(
      account,
      fallback_key,
      fallback_key_size,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_account_unpublished_fallback_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_account_unpublished_fallback_key');
  late final _olm_account_unpublished_fallback_key =
      _olm_account_unpublished_fallback_keyPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Forget about the old fallback key.  This should be called once you are
  /// reasonably certain that you will not receive any more messages that use
  /// the old fallback key (e.g. 5 minutes after the new fallback key has been
  /// published).
  void olm_account_forget_old_fallback_key(
    ffi.Pointer<ffi.NativeType> account,
  ) {
    return _olm_account_forget_old_fallback_key(
      account,
    );
  }

  late final _olm_account_forget_old_fallback_keyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_account_forget_old_fallback_key');
  late final _olm_account_forget_old_fallback_key =
      _olm_account_forget_old_fallback_keyPtr
          .asFunction<void Function(ffi.Pointer<ffi.NativeType>)>();

  /// The number of random bytes needed to create an outbound session
  int olm_create_outbound_session_random_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_create_outbound_session_random_length(
      session,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_create_outbound_session_random_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_create_outbound_session_random_length');
  late final _olm_create_outbound_session_random_length =
      _olm_create_outbound_session_random_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Creates a new out-bound session for sending messages to a given identity_key
  /// and one_time_key. Returns olm_error() on failure. If the keys couldn't be
  /// decoded as base64 then olm_session_last_error() will be "INVALID_BASE64"
  /// If there weren't enough random bytes then olm_session_last_error() will
  /// be "NOT_ENOUGH_RANDOM".
  int olm_create_outbound_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> their_identity_key,
    int their_identity_key_length,
    ffi.Pointer<ffi.Uint8> their_one_time_key,
    int their_one_time_key_length,
    ffi.Pointer<ffi.Uint8> random,
    int random_length,
  ) {
    int result = _olm_create_outbound_session(
      session,
      account,
      their_identity_key,
      their_identity_key_length,
      their_one_time_key,
      their_one_time_key_length,
      random,
      random_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_create_outbound_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_create_outbound_session');
  late final _olm_create_outbound_session =
      _olm_create_outbound_sessionPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<ffi.Uint8>,
              int)>();

  /// Create a new in-bound session for sending/receiving messages from an
  /// incoming PRE_KEY message. Returns olm_error() on failure. If the base64
  /// couldn't be decoded then olm_session_last_error will be "INVALID_BASE64".
  /// If the message was for an unsupported protocol version then
  /// olm_session_last_error() will be "BAD_MESSAGE_VERSION". If the message
  /// couldn't be decoded then olm_session_last_error() will be
  /// "BAD_MESSAGE_FORMAT". If the message refers to an unknown one time
  /// key then olm_session_last_error() will be "BAD_MESSAGE_KEY_ID".
  int olm_create_inbound_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> one_time_key_message,
    int message_length,
  ) {
    int result = _olm_create_inbound_session(
      session,
      account,
      one_time_key_message,
      message_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_create_inbound_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_create_inbound_session');
  late final _olm_create_inbound_session =
      _olm_create_inbound_sessionPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>, int)>();

  /// Same as olm_create_inbound_session, but ensures that the identity key
  /// in the pre-key message matches the expected identity key, supplied via the
  /// `their_identity_key` parameter. Fails early if there is no match.
  int olm_create_inbound_session_from(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.Uint8> their_identity_key,
    int their_identity_key_length,
    ffi.Pointer<ffi.Uint8> one_time_key_message,
    int message_length,
  ) {
    int result = _olm_create_inbound_session_from(
      session,
      account,
      their_identity_key,
      their_identity_key_length,
      one_time_key_message,
      message_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_create_inbound_session_fromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_create_inbound_session_from');
  late final _olm_create_inbound_session_from =
      _olm_create_inbound_session_fromPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// The length of the buffer needed to return the id for this session.
  int olm_session_id_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_session_id_length(
      session,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_session_id_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_session_id_length');
  late final _olm_session_id_length = _olm_session_id_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// An identifier for this session. Will be the same for both ends of the
  /// conversation. If the id buffer is too small then olm_session_last_error()
  /// will be "OUTPUT_BUFFER_TOO_SMALL".
  int olm_session_id(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> id,
    int id_length,
  ) {
    int result = _olm_session_id(
      session,
      id,
      id_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_session_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_session_id');
  late final _olm_session_id = _olm_session_idPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  int olm_session_has_received_message(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_session_has_received_message(
      session,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_session_has_received_messagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_session_has_received_message');
  late final _olm_session_has_received_message =
      _olm_session_has_received_messagePtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Write a null-terminated string describing the internal state of an olm
  /// session to the buffer provided for debugging and logging purposes. If the
  /// buffer is not large enough to hold the entire string, it will be truncated
  /// and will end with "...".  A buffer length of 600 will be enough to hold any
  /// output.
  void olm_session_describe(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<Utf8> buf,
    int buflen,
  ) {
    return _olm_session_describe(
      session,
      buf,
      buflen,
    );
  }

  late final _olm_session_describePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<Utf8>,
              ffi.Size)>>('olm_session_describe');
  late final _olm_session_describe = _olm_session_describePtr.asFunction<
      void Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<Utf8>, int)>();

  /// Checks if the PRE_KEY message is for this in-bound session. This can happen
  /// if multiple messages are sent to this account before this account sends a
  /// message in reply. The one_time_key_message buffer is destroyed. Returns 1 if
  /// the session matches. Returns 0 if the session does not match. Returns
  /// olm_error() on failure. If the base64 couldn't be decoded then
  /// olm_session_last_error will be "INVALID_BASE64".  If the message was for an
  /// unsupported protocol version then olm_session_last_error() will be
  /// "BAD_MESSAGE_VERSION". If the message couldn't be decoded then then
  /// olm_session_last_error() will be "BAD_MESSAGE_FORMAT".
  int olm_matches_inbound_session(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> one_time_key_message,
    int message_length,
  ) {
    int result = _olm_matches_inbound_session(
      session,
      one_time_key_message,
      message_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_matches_inbound_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_matches_inbound_session');
  late final _olm_matches_inbound_session =
      _olm_matches_inbound_sessionPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Checks if the PRE_KEY message is for this in-bound session. This can happen
  /// if multiple messages are sent to this account before this account sends a
  /// message in reply. The one_time_key_message buffer is destroyed. Returns 1 if
  /// the session matches. Returns 0 if the session does not match. Returns
  /// olm_error() on failure. If the base64 couldn't be decoded then
  /// olm_session_last_error will be "INVALID_BASE64".  If the message was for an
  /// unsupported protocol version then olm_session_last_error() will be
  /// "BAD_MESSAGE_VERSION". If the message couldn't be decoded then then
  /// olm_session_last_error() will be "BAD_MESSAGE_FORMAT".
  int olm_matches_inbound_session_from(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> their_identity_key,
    int their_identity_key_length,
    ffi.Pointer<ffi.Uint8> one_time_key_message,
    int message_length,
  ) {
    int result = _olm_matches_inbound_session_from(
      session,
      their_identity_key,
      their_identity_key_length,
      one_time_key_message,
      message_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_matches_inbound_session_fromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_matches_inbound_session_from');
  late final _olm_matches_inbound_session_from =
      _olm_matches_inbound_session_fromPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>, int)>();

  /// Removes the one time keys that the session used from the account. Returns
  /// olm_error() on failure. If the account doesn't have any matching one time
  /// keys then olm_account_last_error() will be "BAD_MESSAGE_KEY_ID".
  int olm_remove_one_time_keys(
    ffi.Pointer<ffi.NativeType> account,
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_remove_one_time_keys(
      account,
      session,
    );
    if (result == olm_error()) throw_olm(olm_account_last_error(account));
    return result;
  }

  late final _olm_remove_one_time_keysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.NativeType>)>>('olm_remove_one_time_keys');
  late final _olm_remove_one_time_keys =
      _olm_remove_one_time_keysPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.NativeType>)>();

  /// The type of the next message that olm_encrypt() will return. Returns
  /// OLM_MESSAGE_TYPE_PRE_KEY if the message will be a PRE_KEY message.
  /// Returns OLM_MESSAGE_TYPE_MESSAGE if the message will be a normal message.
  /// Returns olm_error on failure.
  int olm_encrypt_message_type(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_encrypt_message_type(
      session,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_encrypt_message_typePtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_encrypt_message_type');
  late final _olm_encrypt_message_type = _olm_encrypt_message_typePtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// The number of random bytes needed to encrypt the next message.
  int olm_encrypt_random_length(
    ffi.Pointer<ffi.NativeType> session,
  ) {
    int result = _olm_encrypt_random_length(
      session,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_encrypt_random_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_encrypt_random_length');
  late final _olm_encrypt_random_length = _olm_encrypt_random_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// The size of the next message in bytes for the given number of plain-text
  /// bytes.
  int olm_encrypt_message_length(
    ffi.Pointer<ffi.NativeType> session,
    int plaintext_length,
  ) {
    int result = _olm_encrypt_message_length(
      session,
      plaintext_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_encrypt_message_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>,
              ffi.Size)>>('olm_encrypt_message_length');
  late final _olm_encrypt_message_length = _olm_encrypt_message_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>, int)>();

  /// Encrypts a message using the session. Returns the length of the message in
  /// bytes on success. Writes the message as base64 into the message buffer.
  /// Returns olm_error() on failure. If the message buffer is too small then
  /// olm_session_last_error() will be "OUTPUT_BUFFER_TOO_SMALL". If there
  /// weren't enough random bytes then olm_session_last_error() will be
  /// "NOT_ENOUGH_RANDOM".
  int olm_encrypt(
    ffi.Pointer<ffi.NativeType> session,
    ffi.Pointer<ffi.Uint8> plaintext,
    int plaintext_length,
    ffi.Pointer<ffi.Uint8> random,
    int random_length,
    ffi.Pointer<ffi.Uint8> message,
    int message_length,
  ) {
    int result = _olm_encrypt(
      session,
      plaintext,
      plaintext_length,
      random,
      random_length,
      message,
      message_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_encryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_encrypt');
  late final _olm_encrypt = _olm_encryptPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// The maximum number of bytes of plain-text a given message could decode to.
  /// The actual size could be different due to padding. The input message buffer
  /// is destroyed. Returns olm_error() on failure. If the message base64
  /// couldn't be decoded then olm_session_last_error() will be
  /// "INVALID_BASE64". If the message is for an unsupported version of the
  /// protocol then olm_session_last_error() will be "BAD_MESSAGE_VERSION".
  /// If the message couldn't be decoded then olm_session_last_error() will be
  /// "BAD_MESSAGE_FORMAT".
  int olm_decrypt_max_plaintext_length(
    ffi.Pointer<ffi.NativeType> session,
    int message_type,
    ffi.Pointer<ffi.Uint8> message,
    int message_length,
  ) {
    int result = _olm_decrypt_max_plaintext_length(
      session,
      message_type,
      message,
      message_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_decrypt_max_plaintext_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_decrypt_max_plaintext_length');
  late final _olm_decrypt_max_plaintext_length =
      _olm_decrypt_max_plaintext_lengthPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Decrypts a message using the session. The input message buffer is destroyed.
  /// Returns the length of the plain-text on success. Returns olm_error() on
  /// failure. If the plain-text buffer is smaller than
  /// olm_decrypt_max_plaintext_length() then olm_session_last_error()
  /// will be "OUTPUT_BUFFER_TOO_SMALL". If the base64 couldn't be decoded then
  /// olm_session_last_error() will be "INVALID_BASE64". If the message is for
  /// an unsupported version of the protocol then olm_session_last_error() will
  /// be "BAD_MESSAGE_VERSION". If the message couldn't be decoded then
  /// olm_session_last_error() will be BAD_MESSAGE_FORMAT".
  /// If the MAC on the message was invalid then olm_session_last_error() will
  /// be "BAD_MESSAGE_MAC".
  int olm_decrypt(
    ffi.Pointer<ffi.NativeType> session,
    int message_type,
    ffi.Pointer<ffi.Uint8> message,
    int message_length,
    ffi.Pointer<ffi.Uint8> plaintext,
    int max_plaintext_length,
  ) {
    int result = _olm_decrypt(
      session,
      message_type,
      message,
      message_length,
      plaintext,
      max_plaintext_length,
    );
    if (result == olm_error()) throw_olm(olm_session_last_error(session));
    return result;
  }

  late final _olm_decryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_decrypt');
  late final _olm_decrypt = _olm_decryptPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, int, ffi.Pointer<ffi.Uint8>,
          int, ffi.Pointer<ffi.Uint8>, int)>();

  /// The length of the buffer needed to hold the SHA-256 hash.
  int olm_sha256_length(
    ffi.Pointer<ffi.NativeType> utility,
  ) {
    int result = _olm_sha256_length(
      utility,
    );
    if (result == olm_error()) throw_olm(olm_utility_last_error(utility));
    return result;
  }

  late final _olm_sha256_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_sha256_length');
  late final _olm_sha256_length = _olm_sha256_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Calculates the SHA-256 hash of the input and encodes it as base64. If the
  /// output buffer is smaller than olm_sha256_length() then
  /// olm_utility_last_error() will be "OUTPUT_BUFFER_TOO_SMALL".
  int olm_sha256(
    ffi.Pointer<ffi.NativeType> utility,
    ffi.Pointer<ffi.Uint8> input,
    int input_length,
    ffi.Pointer<ffi.Uint8> output,
    int output_length,
  ) {
    int result = _olm_sha256(
      utility,
      input,
      input_length,
      output,
      output_length,
    );
    if (result == olm_error()) throw_olm(olm_utility_last_error(utility));
    return result;
  }

  late final _olm_sha256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size, ffi.Pointer<ffi.Uint8>, ffi.Size)>>('olm_sha256');
  late final _olm_sha256 = _olm_sha256Ptr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// Verify an ed25519 signature. If the key was too small then
  /// olm_utility_last_error() will be "INVALID_BASE64". If the signature was invalid
  /// then olm_utility_last_error() will be "BAD_MESSAGE_MAC".
  int olm_ed25519_verify(
    ffi.Pointer<ffi.NativeType> utility,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> message,
    int message_length,
    ffi.Pointer<ffi.Uint8> signature,
    int signature_length,
  ) {
    int result = _olm_ed25519_verify(
      utility,
      key,
      key_length,
      message,
      message_length,
      signature,
      signature_length,
    );
    if (result == olm_error()) throw_olm(olm_utility_last_error(utility));
    return result;
  }

  late final _olm_ed25519_verifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_ed25519_verify');
  late final _olm_ed25519_verify = _olm_ed25519_verifyPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// A null terminated string describing the most recent error to happen to an
  /// SAS object.
  ffi.Pointer<Utf8> olm_sas_last_error(
    ffi.Pointer<ffi.NativeType> sas,
  ) {
    return _olm_sas_last_error(
      sas,
    );
  }

  late final _olm_sas_last_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Utf8> Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_sas_last_error');
  late final _olm_sas_last_error = _olm_sas_last_errorPtr
      .asFunction<ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>();

  /// An error code describing the most recent error to happen to an SAS
  /// object.
  OlmErrorCode olm_sas_last_error_code(
    ffi.Pointer<ffi.NativeType> sas,
  ) {
    return OlmErrorCode.fromValue(_olm_sas_last_error_code(
      sas,
    ));
  }

  late final _olm_sas_last_error_codePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_sas_last_error_code');
  late final _olm_sas_last_error_code = _olm_sas_last_error_codePtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// The size of an SAS object in bytes.
  int olm_sas_size() {
    return _olm_sas_size();
  }

  late final _olm_sas_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('olm_sas_size');
  late final _olm_sas_size = _olm_sas_sizePtr.asFunction<int Function()>();

  /// Initialize an SAS object using the supplied memory.
  /// The supplied memory must be at least `olm_sas_size()` bytes.
  ffi.Pointer<ffi.NativeType> olm_sas(
    ffi.Pointer<ffi.Uint8> memory,
  ) {
    return _olm_sas(
      memory,
    );
  }

  late final _olm_sasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeType> Function(
              ffi.Pointer<ffi.Uint8>)>>('olm_sas');
  late final _olm_sas = _olm_sasPtr.asFunction<
      ffi.Pointer<ffi.NativeType> Function(ffi.Pointer<ffi.Uint8>)>();

  /// Clears the memory used to back an SAS object.
  int olm_clear_sas(
    ffi.Pointer<ffi.NativeType> sas,
  ) {
    int result = _olm_clear_sas(
      sas,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_clear_sasPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_clear_sas');
  late final _olm_clear_sas =
      _olm_clear_sasPtr.asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// The number of random bytes needed to create an SAS object.
  int olm_create_sas_random_length(
    ffi.Pointer<ffi.NativeType> sas,
  ) {
    int result = _olm_create_sas_random_length(
      sas,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_create_sas_random_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_create_sas_random_length');
  late final _olm_create_sas_random_length = _olm_create_sas_random_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Creates a new SAS object.
  ///
  /// @param[in] sas the SAS object to create, initialized by `olm_sas()`.
  /// @param[in] random array of random bytes.  The contents of the buffer may be
  /// overwritten.
  /// @param[in] random_length the number of random bytes provided.  Must be at
  /// least `olm_create_sas_random_length()`.
  ///
  /// @return `olm_error()` on failure.  If there weren't enough random bytes then
  /// `olm_sas_last_error()` will be `NOT_ENOUGH_RANDOM`.
  int olm_create_sas(
    ffi.Pointer<ffi.NativeType> sas,
    ffi.Pointer<ffi.Uint8> random,
    int random_length,
  ) {
    int result = _olm_create_sas(
      sas,
      random,
      random_length,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_create_sasPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_create_sas');
  late final _olm_create_sas = _olm_create_sasPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// The size of a public key in bytes.
  int olm_sas_pubkey_length(
    ffi.Pointer<ffi.NativeType> sas,
  ) {
    int result = _olm_sas_pubkey_length(
      sas,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_sas_pubkey_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_sas_pubkey_length');
  late final _olm_sas_pubkey_length = _olm_sas_pubkey_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Get the public key for the SAS object.
  ///
  /// @param[in] sas the SAS object.
  /// @param[out] pubkey buffer to store the public key.
  /// @param[in] pubkey_length the size of the `pubkey` buffer.  Must be at least
  /// `olm_sas_pubkey_length()`.
  ///
  /// @return `olm_error()` on failure.  If the `pubkey` buffer is too small, then
  /// `olm_sas_last_error()` will be `OUTPUT_BUFFER_TOO_SMALL`.
  int olm_sas_get_pubkey(
    ffi.Pointer<ffi.NativeType> sas,
    ffi.Pointer<ffi.Uint8> pubkey,
    int pubkey_length,
  ) {
    int result = _olm_sas_get_pubkey(
      sas,
      pubkey,
      pubkey_length,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_sas_get_pubkeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_sas_get_pubkey');
  late final _olm_sas_get_pubkey = _olm_sas_get_pubkeyPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Sets the public key of other user.
  ///
  /// @param[in] sas the SAS object.
  /// @param[in] their_key the other user's public key.  The contents of the
  /// buffer will be overwritten.
  /// @param[in] their_key_length the size of the `their_key` buffer.
  ///
  /// @return `olm_error()` on failure.  If the `their_key` buffer is too small,
  /// then `olm_sas_last_error()` will be `INPUT_BUFFER_TOO_SMALL`.
  int olm_sas_set_their_key(
    ffi.Pointer<ffi.NativeType> sas,
    ffi.Pointer<ffi.Uint8> their_key,
    int their_key_length,
  ) {
    int result = _olm_sas_set_their_key(
      sas,
      their_key,
      their_key_length,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_sas_set_their_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_sas_set_their_key');
  late final _olm_sas_set_their_key = _olm_sas_set_their_keyPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Checks if their key was set.
  ///
  /// @param[in] sas the SAS object.
  int olm_sas_is_their_key_set(
    ffi.Pointer<ffi.NativeType> sas,
  ) {
    int result = _olm_sas_is_their_key_set(
      sas,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_sas_is_their_key_setPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_sas_is_their_key_set');
  late final _olm_sas_is_their_key_set = _olm_sas_is_their_key_setPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Generate bytes to use for the short authentication string.
  ///
  /// @param[in] sas the SAS object.
  /// @param[in] info extra information to mix in when generating the bytes, as
  /// per the Matrix spec.
  /// @param[in] info_length the length of the `info` parameter.
  /// @param[out] output the output buffer.
  /// @param[in] output_length the size of the output buffer.  For hex-based SAS
  /// as in the Matrix spec, this will be 5.
  ///
  /// @return `olm_error()` on failure. If their key wasn't set then
  /// `olm_sas_last_error()` will be `SAS_THEIR_KEY_NOT_SET`.
  int olm_sas_generate_bytes(
    ffi.Pointer<ffi.NativeType> sas,
    ffi.Pointer<ffi.Uint8> info,
    int info_length,
    ffi.Pointer<ffi.Uint8> output,
    int output_length,
  ) {
    int result = _olm_sas_generate_bytes(
      sas,
      info,
      info_length,
      output,
      output_length,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_sas_generate_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_sas_generate_bytes');
  late final _olm_sas_generate_bytes = _olm_sas_generate_bytesPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// The size of the message authentication code generated by
  /// olm_sas_calculate_mac()`.
  int olm_sas_mac_length(
    ffi.Pointer<ffi.NativeType> sas,
  ) {
    int result = _olm_sas_mac_length(
      sas,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_sas_mac_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_sas_mac_length');
  late final _olm_sas_mac_length = _olm_sas_mac_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Generate a message authentication code (MAC) based on the shared secret.
  ///
  /// @param[in] sas the SAS object.
  /// @param[in] input the message to produce the authentication code for.
  /// @param[in] input_length the length of the message.
  /// @param[in] info extra information to mix in when generating the MAC, as per
  /// the Matrix spec.
  /// @param[in] info_length the length of the `info` parameter.
  /// @param[out] mac the buffer in which to store the MAC.
  /// @param[in] mac_length the size of the `mac` buffer.  Must be at least
  /// `olm_sas_mac_length()`
  ///
  /// @return `olm_error()` on failure.  If the `mac` buffer is too small, then
  /// `olm_sas_last_error()` will be `OUTPUT_BUFFER_TOO_SMALL`.
  int olm_sas_calculate_mac(
    ffi.Pointer<ffi.NativeType> sas,
    ffi.Pointer<ffi.Uint8> input,
    int input_length,
    ffi.Pointer<ffi.Uint8> info,
    int info_length,
    ffi.Pointer<ffi.Uint8> mac,
    int mac_length,
  ) {
    int result = _olm_sas_calculate_mac(
      sas,
      input,
      input_length,
      info,
      info_length,
      mac,
      mac_length,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_sas_calculate_macPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_sas_calculate_mac');
  late final _olm_sas_calculate_mac = _olm_sas_calculate_macPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// A version of the calculate mac function that produces base64 strings that are
  /// compatible with other base64 implementations.
  int olm_sas_calculate_mac_fixed_base64(
    ffi.Pointer<ffi.NativeType> sas,
    ffi.Pointer<ffi.Uint8> input,
    int input_length,
    ffi.Pointer<ffi.Uint8> info,
    int info_length,
    ffi.Pointer<ffi.Uint8> mac,
    int mac_length,
  ) {
    int result = _olm_sas_calculate_mac_fixed_base64(
      sas,
      input,
      input_length,
      info,
      info_length,
      mac,
      mac_length,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_sas_calculate_mac_fixed_base64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_sas_calculate_mac_fixed_base64');
  late final _olm_sas_calculate_mac_fixed_base64 =
      _olm_sas_calculate_mac_fixed_base64Ptr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// for compatibility with an old version of Riot
  int olm_sas_calculate_mac_long_kdf(
    ffi.Pointer<ffi.NativeType> sas,
    ffi.Pointer<ffi.Uint8> input,
    int input_length,
    ffi.Pointer<ffi.Uint8> info,
    int info_length,
    ffi.Pointer<ffi.Uint8> mac,
    int mac_length,
  ) {
    int result = _olm_sas_calculate_mac_long_kdf(
      sas,
      input,
      input_length,
      info,
      info_length,
      mac,
      mac_length,
    );
    if (result == olm_error()) throw_olm(olm_sas_last_error(sas));
    return result;
  }

  late final _olm_sas_calculate_mac_long_kdfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_sas_calculate_mac_long_kdf');
  late final _olm_sas_calculate_mac_long_kdf =
      _olm_sas_calculate_mac_long_kdfPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// The size of an encryption object in bytes
  int olm_pk_encryption_size() {
    return _olm_pk_encryption_size();
  }

  late final _olm_pk_encryption_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'olm_pk_encryption_size');
  late final _olm_pk_encryption_size =
      _olm_pk_encryption_sizePtr.asFunction<int Function()>();

  /// Initialise an encryption object using the supplied memory
  /// The supplied memory must be at least olm_pk_encryption_size() bytes
  ffi.Pointer<ffi.NativeType> olm_pk_encryption(
    ffi.Pointer<ffi.Uint8> memory,
  ) {
    return _olm_pk_encryption(
      memory,
    );
  }

  late final _olm_pk_encryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeType> Function(
              ffi.Pointer<ffi.Uint8>)>>('olm_pk_encryption');
  late final _olm_pk_encryption = _olm_pk_encryptionPtr.asFunction<
      ffi.Pointer<ffi.NativeType> Function(ffi.Pointer<ffi.Uint8>)>();

  /// A null terminated string describing the most recent error to happen to an
  /// encryption object
  ffi.Pointer<Utf8> olm_pk_encryption_last_error(
    ffi.Pointer<ffi.NativeType> encryption,
  ) {
    return _olm_pk_encryption_last_error(
      encryption,
    );
  }

  late final _olm_pk_encryption_last_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Utf8> Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_pk_encryption_last_error');
  late final _olm_pk_encryption_last_error = _olm_pk_encryption_last_errorPtr
      .asFunction<ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>();

  /// An error code describing the most recent error to happen to an encryption
  /// object
  OlmErrorCode olm_pk_encryption_last_error_code(
    ffi.Pointer<ffi.NativeType> encryption,
  ) {
    return OlmErrorCode.fromValue(_olm_pk_encryption_last_error_code(
      encryption,
    ));
  }

  late final _olm_pk_encryption_last_error_codePtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_pk_encryption_last_error_code');
  late final _olm_pk_encryption_last_error_code =
      _olm_pk_encryption_last_error_codePtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Clears the memory used to back this encryption object
  int olm_clear_pk_encryption(
    ffi.Pointer<ffi.NativeType> encryption,
  ) {
    int result = _olm_clear_pk_encryption(
      encryption,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(encryption));
    return result;
  }

  late final _olm_clear_pk_encryptionPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_clear_pk_encryption');
  late final _olm_clear_pk_encryption = _olm_clear_pk_encryptionPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Set the recipient's public key for encrypting to
  int olm_pk_encryption_set_recipient_key(
    ffi.Pointer<ffi.NativeType> encryption,
    ffi.Pointer<ffi.Uint8> public_key,
    int public_key_length,
  ) {
    int result = _olm_pk_encryption_set_recipient_key(
      encryption,
      public_key,
      public_key_length,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(encryption));
    return result;
  }

  late final _olm_pk_encryption_set_recipient_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pk_encryption_set_recipient_key');
  late final _olm_pk_encryption_set_recipient_key =
      _olm_pk_encryption_set_recipient_keyPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Get the length of the ciphertext that will correspond to a plaintext of the
  /// given length.
  int olm_pk_ciphertext_length(
    ffi.Pointer<ffi.NativeType> encryption,
    int plaintext_length,
  ) {
    int result = _olm_pk_ciphertext_length(
      encryption,
      plaintext_length,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(encryption));
    return result;
  }

  late final _olm_pk_ciphertext_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>,
              ffi.Size)>>('olm_pk_ciphertext_length');
  late final _olm_pk_ciphertext_length = _olm_pk_ciphertext_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>, int)>();

  /// Get the length of the message authentication code.
  int olm_pk_mac_length(
    ffi.Pointer<ffi.NativeType> encryption,
  ) {
    int result = _olm_pk_mac_length(
      encryption,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(encryption));
    return result;
  }

  late final _olm_pk_mac_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_pk_mac_length');
  late final _olm_pk_mac_length = _olm_pk_mac_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Get the length of a public or ephemeral key
  int olm_pk_key_length() {
    return _olm_pk_key_length();
  }

  late final _olm_pk_key_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('olm_pk_key_length');
  late final _olm_pk_key_length =
      _olm_pk_key_lengthPtr.asFunction<int Function()>();

  /// The number of random bytes needed to encrypt a message.
  int olm_pk_encrypt_random_length(
    ffi.Pointer<ffi.NativeType> encryption,
  ) {
    int result = _olm_pk_encrypt_random_length(
      encryption,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(encryption));
    return result;
  }

  late final _olm_pk_encrypt_random_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_pk_encrypt_random_length');
  late final _olm_pk_encrypt_random_length = _olm_pk_encrypt_random_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Encrypt a plaintext for the recipient set using
  /// olm_pk_encryption_set_recipient_key. Writes to the ciphertext, mac, and
  /// ephemeral_key buffers, whose values should be sent to the recipient. mac is
  /// a Message Authentication Code to ensure that the data is received and
  /// decrypted properly. ephemeral_key is the public part of the ephemeral key
  /// used (together with the recipient's key) to generate a symmetric encryption
  /// key. Returns olm_error() on failure. If the ciphertext, mac, or
  /// ephemeral_key buffers were too small then olm_pk_encryption_last_error()
  /// will be "OUTPUT_BUFFER_TOO_SMALL". If there weren't enough random bytes then
  /// olm_pk_encryption_last_error() will be "OLM_INPUT_BUFFER_TOO_SMALL".
  int olm_pk_encrypt(
    ffi.Pointer<ffi.NativeType> encryption,
    ffi.Pointer<ffi.Uint8> plaintext,
    int plaintext_length,
    ffi.Pointer<ffi.Uint8> ciphertext,
    int ciphertext_length,
    ffi.Pointer<ffi.Uint8> mac,
    int mac_length,
    ffi.Pointer<ffi.Uint8> ephemeral_key,
    int ephemeral_key_size,
    ffi.Pointer<ffi.Uint8> random,
    int random_length,
  ) {
    int result = _olm_pk_encrypt(
      encryption,
      plaintext,
      plaintext_length,
      ciphertext,
      ciphertext_length,
      mac,
      mac_length,
      ephemeral_key,
      ephemeral_key_size,
      random,
      random_length,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(encryption));
    return result;
  }

  late final _olm_pk_encryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pk_encrypt');
  late final _olm_pk_encrypt = _olm_pk_encryptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.NativeType>,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int)>();

  /// The size of a decryption object in bytes
  int olm_pk_decryption_size() {
    return _olm_pk_decryption_size();
  }

  late final _olm_pk_decryption_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'olm_pk_decryption_size');
  late final _olm_pk_decryption_size =
      _olm_pk_decryption_sizePtr.asFunction<int Function()>();

  /// Initialise a decryption object using the supplied memory
  /// The supplied memory must be at least olm_pk_decryption_size() bytes
  ffi.Pointer<ffi.NativeType> olm_pk_decryption(
    ffi.Pointer<ffi.Uint8> memory,
  ) {
    return _olm_pk_decryption(
      memory,
    );
  }

  late final _olm_pk_decryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeType> Function(
              ffi.Pointer<ffi.Uint8>)>>('olm_pk_decryption');
  late final _olm_pk_decryption = _olm_pk_decryptionPtr.asFunction<
      ffi.Pointer<ffi.NativeType> Function(ffi.Pointer<ffi.Uint8>)>();

  /// A null terminated string describing the most recent error to happen to a
  /// decription object
  ffi.Pointer<Utf8> olm_pk_decryption_last_error(
    ffi.Pointer<ffi.NativeType> decryption,
  ) {
    return _olm_pk_decryption_last_error(
      decryption,
    );
  }

  late final _olm_pk_decryption_last_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Utf8> Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_pk_decryption_last_error');
  late final _olm_pk_decryption_last_error = _olm_pk_decryption_last_errorPtr
      .asFunction<ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>();

  /// An error code describing the most recent error to happen to a decription
  /// object
  OlmErrorCode olm_pk_decryption_last_error_code(
    ffi.Pointer<ffi.NativeType> decryption,
  ) {
    return OlmErrorCode.fromValue(_olm_pk_decryption_last_error_code(
      decryption,
    ));
  }

  late final _olm_pk_decryption_last_error_codePtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_pk_decryption_last_error_code');
  late final _olm_pk_decryption_last_error_code =
      _olm_pk_decryption_last_error_codePtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Clears the memory used to back this decryption object
  int olm_clear_pk_decryption(
    ffi.Pointer<ffi.NativeType> decryption,
  ) {
    int result = _olm_clear_pk_decryption(
      decryption,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(decryption));
    return result;
  }

  late final _olm_clear_pk_decryptionPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_clear_pk_decryption');
  late final _olm_clear_pk_decryption = _olm_clear_pk_decryptionPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Get the number of bytes required to store an olm private key
  int olm_pk_private_key_length() {
    return _olm_pk_private_key_length();
  }

  late final _olm_pk_private_key_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'olm_pk_private_key_length');
  late final _olm_pk_private_key_length =
      _olm_pk_private_key_lengthPtr.asFunction<int Function()>();

  /// DEPRECATED: Use olm_pk_private_key_length()
  int olm_pk_generate_key_random_length() {
    return _olm_pk_generate_key_random_length();
  }

  late final _olm_pk_generate_key_random_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'olm_pk_generate_key_random_length');
  late final _olm_pk_generate_key_random_length =
      _olm_pk_generate_key_random_lengthPtr.asFunction<int Function()>();

  /// Initialise the key from the private part of a key as returned by
  /// olm_pk_get_private_key(). The associated public key will be written to the
  /// pubkey buffer. Returns olm_error() on failure. If the pubkey buffer is too
  /// small then olm_pk_decryption_last_error() will be "OUTPUT_BUFFER_TOO_SMALL".
  /// If the private key was not long enough then olm_pk_decryption_last_error()
  /// will be "OLM_INPUT_BUFFER_TOO_SMALL".
  ///
  /// Note that the pubkey is a base64 encoded string, but the private key is
  /// an unencoded byte array
  int olm_pk_key_from_private(
    ffi.Pointer<ffi.NativeType> decryption,
    ffi.Pointer<ffi.Uint8> pubkey,
    int pubkey_length,
    ffi.Pointer<ffi.Uint8> privkey,
    int privkey_length,
  ) {
    int result = _olm_pk_key_from_private(
      decryption,
      pubkey,
      pubkey_length,
      privkey,
      privkey_length,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(decryption));
    return result;
  }

  late final _olm_pk_key_from_privatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pk_key_from_private');
  late final _olm_pk_key_from_private = _olm_pk_key_from_privatePtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// DEPRECATED: Use olm_pk_key_from_private
  int olm_pk_generate_key(
    ffi.Pointer<ffi.NativeType> decryption,
    ffi.Pointer<ffi.Uint8> pubkey,
    int pubkey_length,
    ffi.Pointer<ffi.Uint8> privkey,
    int privkey_length,
  ) {
    int result = _olm_pk_generate_key(
      decryption,
      pubkey,
      pubkey_length,
      privkey,
      privkey_length,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(decryption));
    return result;
  }

  late final _olm_pk_generate_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pk_generate_key');
  late final _olm_pk_generate_key = _olm_pk_generate_keyPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// Returns the number of bytes needed to store a decryption object.
  int olm_pickle_pk_decryption_length(
    ffi.Pointer<ffi.NativeType> decryption,
  ) {
    int result = _olm_pickle_pk_decryption_length(
      decryption,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(decryption));
    return result;
  }

  late final _olm_pickle_pk_decryption_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_pickle_pk_decryption_length');
  late final _olm_pickle_pk_decryption_length =
      _olm_pickle_pk_decryption_lengthPtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Stores decryption object as a base64 string. Encrypts the object using the
  /// supplied key. Returns the length of the pickled object on success.
  /// Returns olm_error() on failure. If the pickle output buffer
  /// is smaller than olm_pickle_pk_decryption_length() then
  /// olm_pk_decryption_last_error() will be "OUTPUT_BUFFER_TOO_SMALL"
  int olm_pickle_pk_decryption(
    ffi.Pointer<ffi.NativeType> decryption,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> pickled,
    int pickled_length,
  ) {
    int result = _olm_pickle_pk_decryption(
      decryption,
      key,
      key_length,
      pickled,
      pickled_length,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(decryption));
    return result;
  }

  late final _olm_pickle_pk_decryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pickle_pk_decryption');
  late final _olm_pickle_pk_decryption =
      _olm_pickle_pk_decryptionPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>, int)>();

  /// Loads a decryption object from a pickled base64 string. The associated
  /// public key will be written to the pubkey buffer. Decrypts the object using
  /// the supplied key. Returns olm_error() on failure. If the key doesn't
  /// match the one used to encrypt the account then olm_pk_decryption_last_error()
  /// will be "BAD_ACCOUNT_KEY". If the base64 couldn't be decoded then
  /// olm_pk_decryption_last_error() will be "INVALID_BASE64". The input pickled
  /// buffer is destroyed
  int olm_unpickle_pk_decryption(
    ffi.Pointer<ffi.NativeType> decryption,
    ffi.Pointer<ffi.Uint8> key,
    int key_length,
    ffi.Pointer<ffi.Uint8> pickled,
    int pickled_length,
    ffi.Pointer<ffi.Uint8> pubkey,
    int pubkey_length,
  ) {
    int result = _olm_unpickle_pk_decryption(
      decryption,
      key,
      key_length,
      pickled,
      pickled_length,
      pubkey,
      pubkey_length,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(decryption));
    return result;
  }

  late final _olm_unpickle_pk_decryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_unpickle_pk_decryption');
  late final _olm_unpickle_pk_decryption =
      _olm_unpickle_pk_decryptionPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Get the length of the plaintext that will correspond to a ciphertext of the
  /// given length.
  int olm_pk_max_plaintext_length(
    ffi.Pointer<ffi.NativeType> decryption,
    int ciphertext_length,
  ) {
    int result = _olm_pk_max_plaintext_length(
      decryption,
      ciphertext_length,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(decryption));
    return result;
  }

  late final _olm_pk_max_plaintext_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>,
              ffi.Size)>>('olm_pk_max_plaintext_length');
  late final _olm_pk_max_plaintext_length = _olm_pk_max_plaintext_lengthPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>, int)>();

  /// Decrypt a ciphertext. The input ciphertext buffer is destroyed. See the
  /// olm_pk_encrypt function for descriptions of the ephemeral_key and mac
  /// arguments. Returns the length of the plaintext on success. Returns
  /// olm_error() on failure. If the plaintext buffer is too small then
  /// olm_pk_encryption_last_error() will be "OUTPUT_BUFFER_TOO_SMALL".
  int olm_pk_decrypt(
    ffi.Pointer<ffi.NativeType> decryption,
    ffi.Pointer<ffi.Uint8> ephemeral_key,
    int ephemeral_key_length,
    ffi.Pointer<ffi.Uint8> mac,
    int mac_length,
    ffi.Pointer<ffi.Uint8> ciphertext,
    int ciphertext_length,
    ffi.Pointer<ffi.Uint8> plaintext,
    int max_plaintext_length,
  ) {
    int result = _olm_pk_decrypt(
      decryption,
      ephemeral_key,
      ephemeral_key_length,
      mac,
      mac_length,
      ciphertext,
      ciphertext_length,
      plaintext,
      max_plaintext_length,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(decryption));
    return result;
  }

  late final _olm_pk_decryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pk_decrypt');
  late final _olm_pk_decrypt = _olm_pk_decryptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.NativeType>,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int)>();

  /// Get the private key for an OlmDecryption object as an unencoded byte array
  /// private_key must be a pointer to a buffer of at least
  /// olm_pk_private_key_length() bytes and this length must be passed in
  /// private_key_length. If the given buffer is too small, returns olm_error()
  /// and olm_pk_encryption_last_error() will be "OUTPUT_BUFFER_TOO_SMALL".
  /// Returns the number of bytes written.
  int olm_pk_get_private_key(
    ffi.Pointer<ffi.NativeType> decryption,
    ffi.Pointer<ffi.Uint8> private_key,
    int private_key_length,
  ) {
    int result = _olm_pk_get_private_key(
      decryption,
      private_key,
      private_key_length,
    );
    if (result == olm_error())
      throw_olm(olm_pk_decryption_last_error(decryption));
    return result;
  }

  late final _olm_pk_get_private_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pk_get_private_key');
  late final _olm_pk_get_private_key = _olm_pk_get_private_keyPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int)>();

  /// The size of a signing object in bytes
  int olm_pk_signing_size() {
    return _olm_pk_signing_size();
  }

  late final _olm_pk_signing_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('olm_pk_signing_size');
  late final _olm_pk_signing_size =
      _olm_pk_signing_sizePtr.asFunction<int Function()>();

  /// Initialise a signing object using the supplied memory
  /// The supplied memory must be at least olm_pk_signing_size() bytes
  ffi.Pointer<ffi.NativeType> olm_pk_signing(
    ffi.Pointer<ffi.Uint8> memory,
  ) {
    return _olm_pk_signing(
      memory,
    );
  }

  late final _olm_pk_signingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeType> Function(
              ffi.Pointer<ffi.Uint8>)>>('olm_pk_signing');
  late final _olm_pk_signing = _olm_pk_signingPtr.asFunction<
      ffi.Pointer<ffi.NativeType> Function(ffi.Pointer<ffi.Uint8>)>();

  /// A null terminated string describing the most recent error to happen to a
  /// signing object
  ffi.Pointer<Utf8> olm_pk_signing_last_error(
    ffi.Pointer<ffi.NativeType> sign,
  ) {
    return _olm_pk_signing_last_error(
      sign,
    );
  }

  late final _olm_pk_signing_last_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Utf8> Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_pk_signing_last_error');
  late final _olm_pk_signing_last_error = _olm_pk_signing_last_errorPtr
      .asFunction<ffi.Pointer<Utf8> Function(ffi.Pointer<ffi.NativeType>)>();

  /// A null terminated string describing the most recent error to happen to a
  /// signing object
  OlmErrorCode olm_pk_signing_last_error_code(
    ffi.Pointer<ffi.NativeType> sign,
  ) {
    return OlmErrorCode.fromValue(_olm_pk_signing_last_error_code(
      sign,
    ));
  }

  late final _olm_pk_signing_last_error_codePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ffi.NativeType>)>>('olm_pk_signing_last_error_code');
  late final _olm_pk_signing_last_error_code =
      _olm_pk_signing_last_error_codePtr
          .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Clears the memory used to back this signing object
  int olm_clear_pk_signing(
    ffi.Pointer<ffi.NativeType> sign,
  ) {
    int result = _olm_clear_pk_signing(
      sign,
    );
    if (result == olm_error()) throw_olm(olm_pk_signing_last_error(sign));
    return result;
  }

  late final _olm_clear_pk_signingPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.NativeType>)>>(
      'olm_clear_pk_signing');
  late final _olm_clear_pk_signing = _olm_clear_pk_signingPtr
      .asFunction<int Function(ffi.Pointer<ffi.NativeType>)>();

  /// Initialise the signing object with a public/private keypair from a seed. The
  /// associated public key will be written to the pubkey buffer. Returns
  /// olm_error() on failure. If the public key buffer is too small then
  /// olm_pk_signing_last_error() will be "OUTPUT_BUFFER_TOO_SMALL".  If the seed
  /// buffer is too small then olm_pk_signing_last_error() will be
  /// "INPUT_BUFFER_TOO_SMALL".
  int olm_pk_signing_key_from_seed(
    ffi.Pointer<ffi.NativeType> sign,
    ffi.Pointer<ffi.Uint8> pubkey,
    int pubkey_length,
    ffi.Pointer<ffi.Uint8> seed,
    int seed_length,
  ) {
    int result = _olm_pk_signing_key_from_seed(
      sign,
      pubkey,
      pubkey_length,
      seed,
      seed_length,
    );
    if (result == olm_error()) throw_olm(olm_pk_signing_last_error(sign));
    return result;
  }

  late final _olm_pk_signing_key_from_seedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.NativeType>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('olm_pk_signing_key_from_seed');
  late final _olm_pk_signing_key_from_seed =
      _olm_pk_signing_key_from_seedPtr.asFunction<
          int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>, int)>();

  /// The size required for the seed for initialising a signing object.
  int olm_pk_signing_seed_length() {
    return _olm_pk_signing_seed_length();
  }

  late final _olm_pk_signing_seed_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'olm_pk_signing_seed_length');
  late final _olm_pk_signing_seed_length =
      _olm_pk_signing_seed_lengthPtr.asFunction<int Function()>();

  /// The size of the public key of a signing object.
  int olm_pk_signing_public_key_length() {
    return _olm_pk_signing_public_key_length();
  }

  late final _olm_pk_signing_public_key_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'olm_pk_signing_public_key_length');
  late final _olm_pk_signing_public_key_length =
      _olm_pk_signing_public_key_lengthPtr.asFunction<int Function()>();

  /// The size of a signature created by a signing object.
  int olm_pk_signature_length() {
    return _olm_pk_signature_length();
  }

  late final _olm_pk_signature_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'olm_pk_signature_length');
  late final _olm_pk_signature_length =
      _olm_pk_signature_lengthPtr.asFunction<int Function()>();

  /// Sign a message. The signature will be written to the signature
  /// buffer. Returns olm_error() on failure. If the signature buffer is too
  /// small, olm_pk_signing_last_error() will be "OUTPUT_BUFFER_TOO_SMALL".
  int olm_pk_sign(
    ffi.Pointer<ffi.NativeType> sign,
    ffi.Pointer<ffi.Uint8> message,
    int message_length,
    ffi.Pointer<ffi.Uint8> signature,
    int signature_length,
  ) {
    int result = _olm_pk_sign(
      sign,
      message,
      message_length,
      signature,
      signature_length,
    );
    if (result == olm_error()) throw_olm(olm_pk_signing_last_error(sign));
    return result;
  }

  late final _olm_pk_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>,
              ffi.Size, ffi.Pointer<ffi.Uint8>, ffi.Size)>>('olm_pk_sign');
  late final _olm_pk_sign = _olm_pk_signPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeType>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int)>();
}

enum OlmErrorCode {
  /// !< There wasn't an error
  OLM_SUCCESS(0),

  /// !< Not enough entropy was supplied
  OLM_NOT_ENOUGH_RANDOM(1),

  /// !< Supplied output buffer is too small
  OLM_OUTPUT_BUFFER_TOO_SMALL(2),

  /// !< The message version is unsupported
  OLM_BAD_MESSAGE_VERSION(3),

  /// !< The message couldn't be decoded
  OLM_BAD_MESSAGE_FORMAT(4),

  /// !< The message couldn't be decrypted
  OLM_BAD_MESSAGE_MAC(5),

  /// !< The message references an unknown key id
  OLM_BAD_MESSAGE_KEY_ID(6),

  /// !< The input base64 was invalid
  OLM_INVALID_BASE64(7),

  /// !< The supplied account key is invalid
  OLM_BAD_ACCOUNT_KEY(8),

  /// !< The pickled object is too new
  OLM_UNKNOWN_PICKLE_VERSION(9),

  /// !< The pickled object couldn't be decoded
  OLM_CORRUPTED_PICKLE(10),

  /// !< Attempt to initialise an inbound group
  /// session from an invalid session key
  OLM_BAD_SESSION_KEY(11),

  /// !< Attempt to decode a message whose
  /// index is earlier than our earliest
  /// known session key.
  OLM_UNKNOWN_MESSAGE_INDEX(12),

  /// Attempt to unpickle an account which uses pickle version 1 (which did
  /// not save enough space for the Ed25519 key; the key should be considered
  /// compromised. We don't let the user reload the account.
  OLM_BAD_LEGACY_ACCOUNT_PICKLE(13),

  /// Received message had a bad signature
  OLM_BAD_SIGNATURE(14),
  OLM_INPUT_BUFFER_TOO_SMALL(15),

  /// SAS doesn't have their key set.
  OLM_SAS_THEIR_KEY_NOT_SET(16),

  /// The pickled object was successfully decoded, but the unpickling still failed
  /// because it had some extraneous junk data at the end.
  OLM_PICKLE_EXTRA_DATA(17);

  final int value;
  const OlmErrorCode(this.value);

  static OlmErrorCode fromValue(int value) => switch (value) {
        0 => OLM_SUCCESS,
        1 => OLM_NOT_ENOUGH_RANDOM,
        2 => OLM_OUTPUT_BUFFER_TOO_SMALL,
        3 => OLM_BAD_MESSAGE_VERSION,
        4 => OLM_BAD_MESSAGE_FORMAT,
        5 => OLM_BAD_MESSAGE_MAC,
        6 => OLM_BAD_MESSAGE_KEY_ID,
        7 => OLM_INVALID_BASE64,
        8 => OLM_BAD_ACCOUNT_KEY,
        9 => OLM_UNKNOWN_PICKLE_VERSION,
        10 => OLM_CORRUPTED_PICKLE,
        11 => OLM_BAD_SESSION_KEY,
        12 => OLM_UNKNOWN_MESSAGE_INDEX,
        13 => OLM_BAD_LEGACY_ACCOUNT_PICKLE,
        14 => OLM_BAD_SIGNATURE,
        15 => OLM_INPUT_BUFFER_TOO_SMALL,
        16 => OLM_SAS_THEIR_KEY_NOT_SET,
        17 => OLM_PICKLE_EXTRA_DATA,
        _ => throw ArgumentError('Unknown value for OlmErrorCode: $value'),
      };
}
